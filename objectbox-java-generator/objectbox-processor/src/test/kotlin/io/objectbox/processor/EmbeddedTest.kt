/*
 * ObjectBox Build Tools
 * Copyright (C) 2025 ObjectBox Ltd.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package io.objectbox.processor

import com.google.common.truth.Truth.assertThat
import org.intellij.lang.annotations.Language
import org.junit.Test


class EmbeddedTest : BaseProcessorTest() {

    @Language("Java")
    private val addressSource =
        """
        package com.example;

        public class Address {
            public String street;
            public String city;
            public int zip;

            public Address() {}
            public Address(String street, String city, int zip) {
                this.street = street;
                this.city = city;
                this.zip = zip;
            }

            public String getStreet() { return street; }
            public void setStreet(String street) { this.street = street; }
            public String getCity() { return city; }
            public void setCity(String city) { this.city = city; }
            public int getZip() { return zip; }
            public void setZip(int zip) { this.zip = zip; }
        }
        """.trimIndent()

    @Test
    fun basicEmbeddedEntity() {
        @Language("Java")
        val entitySource =
            """
            package com.example;
            import io.objectbox.annotation.Embedded;
            import io.objectbox.annotation.Entity;
            import io.objectbox.annotation.Id;

            @Entity
            public class EmbeddedEntity {
                @Id long id;
                String name;
                @Embedded Address address;

                public EmbeddedEntity() {}
                public EmbeddedEntity(long id, String name, String address_street, String address_city, int address_zip) {
                    this.id = id;
                    this.name = name;
                    if (address_street != null || address_city != null || address_zip != 0) {
                        this.address = new Address(address_street, address_city, address_zip);
                    }
                }

                public long getId() { return id; }
                public void setId(long id) { this.id = id; }
                public String getName() { return name; }
                public void setName(String name) { this.name = name; }
                public Address getAddress() { return address; }
                public void setAddress(Address address) { this.address = address; }
            }
            """.trimIndent()

        val env = TestEnvironment("embedded-basic.json", useTemporaryModelFile = true)
            .apply {
                addSourceFile("com.example.Address", addressSource)
                addSourceFile("com.example.EmbeddedEntity", entitySource)
            }

        env.compile()
            .assertThatIt {
                succeededWithoutWarnings()

                @Language("Java")
                val expectedCursor =
                    """
                    package com.example;

                    import io.objectbox.BoxStore;
                    import io.objectbox.Cursor;
                    import io.objectbox.annotation.apihint.Internal;
                    import io.objectbox.internal.CursorFactory;

                    // THIS CODE IS GENERATED BY ObjectBox, DO NOT EDIT.

                    /**
                     * ObjectBox generated Cursor implementation for "EmbeddedEntity".
                     * Note that this is a low-level class: usually you should stick to the Box class.
                     */
                    public final class EmbeddedEntityCursor extends Cursor<EmbeddedEntity> {
                        @Internal
                        static final class Factory implements CursorFactory<EmbeddedEntity> {
                            @Override
                            public Cursor<EmbeddedEntity> createCursor(io.objectbox.Transaction tx, long cursorHandle, BoxStore boxStoreForEntities) {
                                return new EmbeddedEntityCursor(tx, cursorHandle, boxStoreForEntities);
                            }
                        }

                        private static final EmbeddedEntity_.EmbeddedEntityIdGetter ID_GETTER = EmbeddedEntity_.__ID_GETTER;


                        private final static int __ID_name = EmbeddedEntity_.name.id;
                        private final static int __ID_address_street = EmbeddedEntity_.address_street.id;
                        private final static int __ID_address_city = EmbeddedEntity_.address_city.id;
                        private final static int __ID_address_zip = EmbeddedEntity_.address_zip.id;

                        public EmbeddedEntityCursor(io.objectbox.Transaction tx, long cursor, BoxStore boxStore) {
                            super(tx, cursor, EmbeddedEntity_.__INSTANCE, boxStore);
                        }

                        @Override
                        public long getId(EmbeddedEntity entity) {
                            return ID_GETTER.getId(entity);
                        }

                        /**
                         * Puts an object into its box.
                         *
                         * @return The ID of the object within its box.
                         */
                        @SuppressWarnings({"rawtypes", "unchecked"})
                        @Override
                        public long put(EmbeddedEntity entity) {
                            Address address = entity.address;

                            String name = entity.name;
                            int __id1 = name != null ? __ID_name : 0;
                            String address_street = address != null ? address.street : null;
                            int __id2 = address_street != null ? __ID_address_street : 0;
                            String address_city = address != null ? address.city : null;
                            int __id3 = address_city != null ? __ID_address_city : 0;
                            int __id4 = address != null ? __ID_address_zip : 0;

                            long __assignedId = collect313311(cursor, entity.id, PUT_FLAG_FIRST | PUT_FLAG_COMPLETE,
                                    __id1, name, __id2, address_street,
                                    __id3, address_city, 0, null,
                                    __id4, address != null ? address.zip : 0, 0, 0,
                                    0, 0, 0, 0,
                                    0, 0, 0, 0,
                                    0, 0, 0, 0);

                            entity.id = __assignedId;

                            return __assignedId;
                        }

                    }
                    """.trimIndent()
                generatedSourceFileMatches("com.example.EmbeddedEntityCursor", expectedCursor)

                // Item 1: Verify generated EntityInfo has correct flat property declarations
                @Language("Java")
                val expectedEntityInfo =
                    """
                    package com.example;

                    import com.example.EmbeddedEntityCursor.Factory;
                    import io.objectbox.EntityInfo;
                    import io.objectbox.annotation.apihint.Internal;
                    import io.objectbox.internal.CursorFactory;
                    import io.objectbox.internal.IdGetter;

                    // THIS CODE IS GENERATED BY ObjectBox, DO NOT EDIT.

                    /**
                     * Properties for entity "EmbeddedEntity". Can be used for QueryBuilder and for referencing DB names.
                     */
                    public final class EmbeddedEntity_ implements EntityInfo<EmbeddedEntity> {

                        // Leading underscores for static constants to avoid naming conflicts with property names

                        public static final String __ENTITY_NAME = "EmbeddedEntity";

                        public static final int __ENTITY_ID = 1;

                        public static final Class<EmbeddedEntity> __ENTITY_CLASS = EmbeddedEntity.class;

                        public static final String __DB_NAME = "EmbeddedEntity";

                        public static final CursorFactory<EmbeddedEntity> __CURSOR_FACTORY = new Factory();

                        @Internal
                        static final EmbeddedEntityIdGetter __ID_GETTER = new EmbeddedEntityIdGetter();

                        public final static EmbeddedEntity_ __INSTANCE = new EmbeddedEntity_();

                        public final static io.objectbox.Property<EmbeddedEntity> id =
                            new io.objectbox.Property<>(__INSTANCE, 0, 1, long.class, "id", true, "id");

                        public final static io.objectbox.Property<EmbeddedEntity> name =
                            new io.objectbox.Property<>(__INSTANCE, 1, 2, String.class, "name");

                        public final static io.objectbox.Property<EmbeddedEntity> address_street =
                            new io.objectbox.Property<>(__INSTANCE, 2, 3, String.class, "address_street");

                        public final static io.objectbox.Property<EmbeddedEntity> address_city =
                            new io.objectbox.Property<>(__INSTANCE, 3, 4, String.class, "address_city");

                        public final static io.objectbox.Property<EmbeddedEntity> address_zip =
                            new io.objectbox.Property<>(__INSTANCE, 4, 5, int.class, "address_zip");

                        @SuppressWarnings("unchecked")
                        public final static io.objectbox.Property<EmbeddedEntity>[] __ALL_PROPERTIES = new io.objectbox.Property[]{
                            id,
                            name,
                            address_street,
                            address_city,
                            address_zip
                        };

                        public final static io.objectbox.Property<EmbeddedEntity> __ID_PROPERTY = id;

                        @Override
                        public String getEntityName() {
                            return __ENTITY_NAME;
                        }

                        @Override
                        public int getEntityId() {
                            return __ENTITY_ID;
                        }

                        @Override
                        public Class<EmbeddedEntity> getEntityClass() {
                            return __ENTITY_CLASS;
                        }

                        @Override
                        public String getDbName() {
                            return __DB_NAME;
                        }

                        @Override
                        public io.objectbox.Property<EmbeddedEntity>[] getAllProperties() {
                            return __ALL_PROPERTIES;
                        }

                        @Override
                        public io.objectbox.Property<EmbeddedEntity> getIdProperty() {
                            return __ID_PROPERTY;
                        }

                        @Override
                        public IdGetter<EmbeddedEntity> getIdGetter() {
                            return __ID_GETTER;
                        }

                        @Override
                        public CursorFactory<EmbeddedEntity> getCursorFactory() {
                            return __CURSOR_FACTORY;
                        }

                        @Internal
                        static final class EmbeddedEntityIdGetter implements IdGetter<EmbeddedEntity> {
                            @Override
                            public long getId(EmbeddedEntity object) {
                                return object.id;
                            }
                        }

                    }
                    """.trimIndent()
                generatedSourceFileMatches("com.example.EmbeddedEntity_", expectedEntityInfo)
            }

        // Item 5: Verify all-args constructor is detected and properties are correct
        val entity = env.schema.entities.single { it.className == "EmbeddedEntity" }
        assertThat(entity.hasAllArgsConstructor()).isTrue()
        assertThat(entity.properties).hasSize(5)
    }

    @Test
    fun customPrefix() {
        @Language("Java")
        val entitySource =
            """
            package com.example;
            import io.objectbox.annotation.Embedded;
            import io.objectbox.annotation.Entity;
            import io.objectbox.annotation.Id;

            @Entity
            public class PrefixEntity {
                @Id long id;
                @Embedded(prefix = "loc_") Address address;

                public PrefixEntity() {}
                public PrefixEntity(long id, String loc_street, String loc_city, int loc_zip) {
                    this.id = id;
                    if (loc_street != null || loc_city != null || loc_zip != 0) {
                        this.address = new Address(loc_street, loc_city, loc_zip);
                    }
                }

                public long getId() { return id; }
                public void setId(long id) { this.id = id; }
                public Address getAddress() { return address; }
                public void setAddress(Address address) { this.address = address; }
            }
            """.trimIndent()

        val compilation = TestEnvironment("embedded-prefix.json", useTemporaryModelFile = true)
            .apply {
                addSourceFile("com.example.Address", addressSource)
                addSourceFile("com.example.PrefixEntity", entitySource)
            }
            .compile()

        compilation.assertThatIt {
            succeededWithoutWarnings()
        }

        // Verify that the generated EntityInfo uses the custom prefix
        val schema = compilation.let {
            // Access schema through the test environment processor - verify property names
            // For now just verify compilation succeeds; detailed source matching can be added later
        }
    }

    @Test
    fun errorEmbeddedClassHasId() {
        @Language("Java")
        val badEmbedded =
            """
            package com.example;
            import io.objectbox.annotation.Id;

            public class BadEmbedded {
                @Id long id;
                String value;

                public BadEmbedded() {}
            }
            """.trimIndent()

        @Language("Java")
        val entitySource =
            """
            package com.example;
            import io.objectbox.annotation.Embedded;
            import io.objectbox.annotation.Entity;
            import io.objectbox.annotation.Id;

            @Entity
            public class BadEntity {
                @Id long id;
                @Embedded BadEmbedded embedded;

                public BadEntity() {}
            }
            """.trimIndent()

        TestEnvironment("embedded-error-id.json", useTemporaryModelFile = true)
            .apply {
                addSourceFile("com.example.BadEmbedded", badEmbedded)
                addSourceFile("com.example.BadEntity", entitySource)
            }
            .compile()
            .assertThatIt {
                failed()
                hadErrorContaining("@Embedded")
            }
    }

    @Test
    fun errorUnsupportedEmbeddedFieldType() {
        @Language("Java")
        val customType =
            """
            package com.example;

            public class CustomType {
                public int value;
            }
            """.trimIndent()

        @Language("Java")
        val badEmbedded =
            """
            package com.example;

            public class UnsupportedEmbedded {
                String name;
                CustomType custom;

                public UnsupportedEmbedded() {}
            }
            """.trimIndent()

        @Language("Java")
        val entitySource =
            """
            package com.example;
            import io.objectbox.annotation.Embedded;
            import io.objectbox.annotation.Entity;
            import io.objectbox.annotation.Id;

            @Entity
            public class UnsupportedEntity {
                @Id long id;
                @Embedded UnsupportedEmbedded embedded;

                public UnsupportedEntity() {}
            }
            """.trimIndent()

        TestEnvironment("embedded-error-type.json", useTemporaryModelFile = true)
            .apply {
                addSourceFile("com.example.CustomType", customType)
                addSourceFile("com.example.UnsupportedEmbedded", badEmbedded)
                addSourceFile("com.example.UnsupportedEntity", entitySource)
            }
            .compile()
            .assertThatIt {
                failed()
                hadErrorContaining("is not supported")
            }
    }

    @Test
    fun multipleEmbeddedSameType() {
        @Language("Java")
        val entitySource =
            """
            package com.example;
            import io.objectbox.annotation.Embedded;
            import io.objectbox.annotation.Entity;
            import io.objectbox.annotation.Id;

            @Entity
            public class MultiEmbeddedEntity {
                @Id long id;
                @Embedded(prefix = "home_") Address homeAddress;
                @Embedded(prefix = "work_") Address workAddress;

                public MultiEmbeddedEntity() {}
                public MultiEmbeddedEntity(long id,
                        String home_street, String home_city, int home_zip,
                        String work_street, String work_city, int work_zip) {
                    this.id = id;
                    if (home_street != null || home_city != null || home_zip != 0) {
                        this.homeAddress = new Address(home_street, home_city, home_zip);
                    }
                    if (work_street != null || work_city != null || work_zip != 0) {
                        this.workAddress = new Address(work_street, work_city, work_zip);
                    }
                }

                public long getId() { return id; }
                public void setId(long id) { this.id = id; }
                public Address getHomeAddress() { return homeAddress; }
                public void setHomeAddress(Address homeAddress) { this.homeAddress = homeAddress; }
                public Address getWorkAddress() { return workAddress; }
                public void setWorkAddress(Address workAddress) { this.workAddress = workAddress; }
            }
            """.trimIndent()

        val env = TestEnvironment("embedded-multi.json", useTemporaryModelFile = true)
            .apply {
                addSourceFile("com.example.Address", addressSource)
                addSourceFile("com.example.MultiEmbeddedEntity", entitySource)
            }

        env.compile()
            .assertThatIt {
                succeededWithoutWarnings()
            }

        // Verify schema has all 7 properties: id + 3 from home + 3 from work
        val entity = env.schema.entities.single { it.className == "MultiEmbeddedEntity" }
        assertThat(entity.hasAllArgsConstructor()).isTrue()
        assertThat(entity.properties).hasSize(7)
        val propNames = entity.properties.map { it.propertyName }
        assertThat(propNames).containsExactly(
            "id", "home_street", "home_city", "home_zip",
            "work_street", "work_city", "work_zip"
        ).inOrder()
    }

    @Test
    fun privateFieldsInEmbeddedClass() {
        @Language("Java")
        val privateAddressSource =
            """
            package com.example;

            public class PrivateAddress {
                private String street;
                private String city;
                private int zip;

                public PrivateAddress() {}
                public PrivateAddress(String street, String city, int zip) {
                    this.street = street;
                    this.city = city;
                    this.zip = zip;
                }

                public String getStreet() { return street; }
                public void setStreet(String street) { this.street = street; }
                public String getCity() { return city; }
                public void setCity(String city) { this.city = city; }
                public int getZip() { return zip; }
                public void setZip(int zip) { this.zip = zip; }
            }
            """.trimIndent()

        @Language("Java")
        val entitySource =
            """
            package com.example;
            import io.objectbox.annotation.Embedded;
            import io.objectbox.annotation.Entity;
            import io.objectbox.annotation.Id;

            @Entity
            public class PrivateFieldEntity {
                @Id long id;
                @Embedded PrivateAddress address;

                public PrivateFieldEntity() {}
                public PrivateFieldEntity(long id, String address_street, String address_city, int address_zip) {
                    this.id = id;
                    if (address_street != null || address_city != null || address_zip != 0) {
                        this.address = new PrivateAddress(address_street, address_city, address_zip);
                    }
                }

                public long getId() { return id; }
                public void setId(long id) { this.id = id; }
                public PrivateAddress getAddress() { return address; }
                public void setAddress(PrivateAddress address) { this.address = address; }
            }
            """.trimIndent()

        TestEnvironment("embedded-private.json", useTemporaryModelFile = true)
            .apply {
                addSourceFile("com.example.PrivateAddress", privateAddressSource)
                addSourceFile("com.example.PrivateFieldEntity", entitySource)
            }
            .compile()
            .assertThatIt {
                succeededWithoutWarnings()

                // Verify cursor uses getter methods (getStreet(), getCity(), getZip()) instead of field access
                @Language("Java")
                val expectedCursor =
                    """
                    package com.example;

                    import io.objectbox.BoxStore;
                    import io.objectbox.Cursor;
                    import io.objectbox.annotation.apihint.Internal;
                    import io.objectbox.internal.CursorFactory;

                    // THIS CODE IS GENERATED BY ObjectBox, DO NOT EDIT.

                    /**
                     * ObjectBox generated Cursor implementation for "PrivateFieldEntity".
                     * Note that this is a low-level class: usually you should stick to the Box class.
                     */
                    public final class PrivateFieldEntityCursor extends Cursor<PrivateFieldEntity> {
                        @Internal
                        static final class Factory implements CursorFactory<PrivateFieldEntity> {
                            @Override
                            public Cursor<PrivateFieldEntity> createCursor(io.objectbox.Transaction tx, long cursorHandle, BoxStore boxStoreForEntities) {
                                return new PrivateFieldEntityCursor(tx, cursorHandle, boxStoreForEntities);
                            }
                        }

                        private static final PrivateFieldEntity_.PrivateFieldEntityIdGetter ID_GETTER = PrivateFieldEntity_.__ID_GETTER;


                        private final static int __ID_address_street = PrivateFieldEntity_.address_street.id;
                        private final static int __ID_address_city = PrivateFieldEntity_.address_city.id;
                        private final static int __ID_address_zip = PrivateFieldEntity_.address_zip.id;

                        public PrivateFieldEntityCursor(io.objectbox.Transaction tx, long cursor, BoxStore boxStore) {
                            super(tx, cursor, PrivateFieldEntity_.__INSTANCE, boxStore);
                        }

                        @Override
                        public long getId(PrivateFieldEntity entity) {
                            return ID_GETTER.getId(entity);
                        }

                        /**
                         * Puts an object into its box.
                         *
                         * @return The ID of the object within its box.
                         */
                        @SuppressWarnings({"rawtypes", "unchecked"})
                        @Override
                        public long put(PrivateFieldEntity entity) {
                            PrivateAddress address = entity.address;

                            String address_street = address != null ? address.getStreet() : null;
                            int __id1 = address_street != null ? __ID_address_street : 0;
                            String address_city = address != null ? address.getCity() : null;
                            int __id2 = address_city != null ? __ID_address_city : 0;
                            int __id3 = address != null ? __ID_address_zip : 0;

                            long __assignedId = collect313311(cursor, entity.id, PUT_FLAG_FIRST | PUT_FLAG_COMPLETE,
                                    __id1, address_street, __id2, address_city,
                                    0, null, 0, null,
                                    __id3, address != null ? address.getZip() : 0, 0, 0,
                                    0, 0, 0, 0,
                                    0, 0, 0, 0,
                                    0, 0, 0, 0);

                            entity.id = __assignedId;

                            return __assignedId;
                        }

                    }
                    """.trimIndent()
                generatedSourceFileMatches("com.example.PrivateFieldEntityCursor", expectedCursor)
            }
    }

    @Test
    fun nameInDbOnEmbeddedField() {
        @Language("Java")
        val namedAddressSource =
            """
            package com.example;
            import io.objectbox.annotation.NameInDb;

            public class NamedAddress {
                @NameInDb("str") public String street;
                @NameInDb("cty") public String city;
                public int zip;

                public NamedAddress() {}
            }
            """.trimIndent()

        @Language("Java")
        val entitySource =
            """
            package com.example;
            import io.objectbox.annotation.Embedded;
            import io.objectbox.annotation.Entity;
            import io.objectbox.annotation.Id;

            @Entity
            public class NamedEmbeddedEntity {
                @Id long id;
                @Embedded NamedAddress address;

                public NamedEmbeddedEntity() {}
            }
            """.trimIndent()

        val env = TestEnvironment("embedded-nameInDb.json", useTemporaryModelFile = true)
            .apply {
                addSourceFile("com.example.NamedAddress", namedAddressSource)
                addSourceFile("com.example.NamedEmbeddedEntity", entitySource)
            }

        env.compile()
            .assertThatIt {
                succeededWithoutWarnings()
            }

        // Verify the flat properties have custom dbNames from @NameInDb
        val entity = env.schema.entities.single { it.className == "NamedEmbeddedEntity" }
        val streetProp = entity.properties.single { it.propertyName == "address_street" }
        assertThat(streetProp.dbName).isEqualTo("address_str")
        val cityProp = entity.properties.single { it.propertyName == "address_city" }
        assertThat(cityProp.dbName).isEqualTo("address_cty")
        // zip has no @NameInDb, so dbName should match propertyName
        val zipProp = entity.properties.single { it.propertyName == "address_zip" }
        assertThat(zipProp.dbName).isEqualTo("address_zip")
    }

    @Test
    fun indexOnEmbeddedField() {
        @Language("Java")
        val indexedAddressSource =
            """
            package com.example;
            import io.objectbox.annotation.Index;

            public class IndexedAddress {
                @Index public String street;
                public String city;
                public int zip;

                public IndexedAddress() {}
            }
            """.trimIndent()

        @Language("Java")
        val entitySource =
            """
            package com.example;
            import io.objectbox.annotation.Embedded;
            import io.objectbox.annotation.Entity;
            import io.objectbox.annotation.Id;

            @Entity
            public class IndexedEmbeddedEntity {
                @Id long id;
                @Embedded IndexedAddress address;

                public IndexedEmbeddedEntity() {}
            }
            """.trimIndent()

        val env = TestEnvironment("embedded-index.json", useTemporaryModelFile = true)
            .apply {
                addSourceFile("com.example.IndexedAddress", indexedAddressSource)
                addSourceFile("com.example.IndexedEmbeddedEntity", entitySource)
            }

        env.compile()
            .assertThatIt {
                succeededWithoutWarnings()
            }

        // Verify the address_street property is indexed
        val entity = env.schema.entities.single { it.className == "IndexedEmbeddedEntity" }
        assertThat(entity.indexes).hasSize(1)
        val index = entity.indexes[0]
        assertThat(index.properties).hasSize(1)
        assertThat(index.properties[0].propertyName).isEqualTo("address_street")
    }

    @Test
    fun nestedEmbedded() {
        @Language("Java")
        val geoLocationSource =
            """
            package com.example;

            public class GeoLocation {
                public double latitude;
                public double longitude;

                public GeoLocation() {}
                public GeoLocation(double latitude, double longitude) {
                    this.latitude = latitude;
                    this.longitude = longitude;
                }
            }
            """.trimIndent()

        @Language("Java")
        val nestedAddressSource =
            """
            package com.example;
            import io.objectbox.annotation.Embedded;

            public class NestedAddress {
                public String street;
                @Embedded public GeoLocation geo;

                public NestedAddress() {}
            }
            """.trimIndent()

        @Language("Java")
        val entitySource =
            """
            package com.example;
            import io.objectbox.annotation.Embedded;
            import io.objectbox.annotation.Entity;
            import io.objectbox.annotation.Id;

            @Entity
            public class NestedEmbeddedEntity {
                @Id long id;
                @Embedded NestedAddress address;

                public NestedEmbeddedEntity() {}
                public NestedEmbeddedEntity(long id, String address_street,
                        double address_geo_latitude, double address_geo_longitude) {
                    this.id = id;
                }

                public long getId() { return id; }
                public void setId(long id) { this.id = id; }
                public NestedAddress getAddress() { return address; }
                public void setAddress(NestedAddress address) { this.address = address; }
            }
            """.trimIndent()

        val env = TestEnvironment("embedded-nested.json", useTemporaryModelFile = true)
            .apply {
                addSourceFile("com.example.GeoLocation", geoLocationSource)
                addSourceFile("com.example.NestedAddress", nestedAddressSource)
                addSourceFile("com.example.NestedEmbeddedEntity", entitySource)
            }

        env.compile()
            .assertThatIt {
                succeededWithoutWarnings()
            }

        // Verify schema has all flat properties including nested
        val entity = env.schema.entities.single { it.className == "NestedEmbeddedEntity" }
        assertThat(entity.hasAllArgsConstructor()).isTrue()
        val propNames = entity.properties.map { it.propertyName }
        assertThat(propNames).containsExactly(
            "id", "address_street", "address_geo_latitude", "address_geo_longitude"
        ).inOrder()
    }

    /**
     * Tests @Embedded with Kotlin data class pattern (decompiled to Java):
     * private fields, public final getters, all-args constructor with argN parameter names.
     */
    @Test
    fun kotlinDataClassEmbedded() {
        // Decompiled Kotlin: data class KotlinAddress(val street: String, val city: String, val zip: Int)
        @Language("Java")
        val kotlinAddressSource =
            """
            package com.example;

            public final class KotlinAddress {
                private final String street;
                private final String city;
                private final int zip;

                public final String getStreet() { return this.street; }
                public final String getCity() { return this.city; }
                public final int getZip() { return this.zip; }

                public KotlinAddress(String street, String city, int zip) {
                    this.street = street;
                    this.city = city;
                    this.zip = zip;
                }
            }
            """.trimIndent()

        // Decompiled Kotlin: @Entity data class KotlinEmbeddedEntity(@Id var id: Long = 0, @Embedded val address: KotlinAddress)
        @Language("Java")
        val entitySource =
            """
            package com.example;
            import io.objectbox.annotation.Embedded;
            import io.objectbox.annotation.Entity;
            import io.objectbox.annotation.Id;

            @Entity
            public final class KotlinEmbeddedEntity {
                @Id private long id;
                @Embedded private KotlinAddress address;

                public final long getId() { return this.id; }
                public final void setId(long var1) { this.id = var1; }
                public final KotlinAddress getAddress() { return this.address; }
                public final void setAddress(KotlinAddress var1) { this.address = var1; }

                public KotlinEmbeddedEntity(long arg0, String arg1, String arg2, int arg3) {
                    this.id = arg0;
                    if (arg1 != null || arg2 != null || arg3 != 0) {
                        this.address = new KotlinAddress(arg1, arg2, arg3);
                    }
                }

                public KotlinEmbeddedEntity() {}
            }
            """.trimIndent()

        val env = TestEnvironment("embedded-kotlin.json", useTemporaryModelFile = true)
            .apply {
                addSourceFile("com.example.KotlinAddress", kotlinAddressSource)
                addSourceFile("com.example.KotlinEmbeddedEntity", entitySource)
            }

        env.compile()
            .assertThatIt {
                succeededWithoutWarnings()
            }

        // Verify schema
        val entity = env.schema.entities.single { it.className == "KotlinEmbeddedEntity" }
        assertThat(entity.hasAllArgsConstructor()).isTrue()
        assertThat(entity.properties).hasSize(4)
        val propNames = entity.properties.map { it.propertyName }
        assertThat(propNames).containsExactly("id", "address_street", "address_city", "address_zip").inOrder()
    }
}
